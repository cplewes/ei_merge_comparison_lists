--- /home/cplewes/dev/ei_merge_comparison_lists/original/lta/src/com/agfa/ris/client/lta/textarea/studylist/ComposedStudyListController.java	2025-09-17 14:53:51.381378368 -0600
+++ /home/cplewes/dev/ei_merge_comparison_lists/src/lta/java/com/agfa/ris/client/lta/textarea/studylist/ComposedStudyListController.java	2025-09-19 14:53:51.098184326 -0600
@@ -63,6 +63,7 @@
 import com.agfa.ris.client.lta.textarea.event.RemoveFromListEvent;
 import com.agfa.ris.client.lta.textarea.event.RemovedStudyEvent;
 import com.agfa.ris.client.lta.textarea.event.StudySelectionEvent;
+import com.agfa.ris.client.lta.textarea.event.TriggerAutoSearchForAddedComparisonEvent;
 import com.agfa.ris.client.lta.textarea.event.UpdateStudyObjectListEvent;
 import com.agfa.ris.client.lta.textarea.overview.SelectedStudyModel;
 import com.agfa.ris.client.lta.textarea.reporting.ReportingContext;
@@ -106,6 +107,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.stream.Collectors;
@@ -141,6 +143,7 @@
     private final List<StudyListObject> moveToActiveStudyList = new ArrayList<StudyListObject>();
     private IReportSeverityObservable reportSeverityObservable;
     private boolean additionalComparisonsLoaded = false;
+    private boolean isBlendingActive = false;
     private DisplayStrategy displayStrategy;
     private ImageAreaGateway gateway;
     private PopupMenuListener popupListener;
@@ -153,6 +156,22 @@
         this.comparisons = new ArrayList<ComparisonStudyListController>();
         this.comparisonAddedList = Lists.newArrayList();
         this.tceList = Lists.newArrayList();
+
+        // Test logging system on initialization
+        this.logDebug("EI_DEBUG: ComposedStudyListController initialized - testing file logging");
+
+        // Test logging from background thread to verify threading works
+        Thread testThread = new Thread(() -> {
+            try {
+                Thread.sleep(100); // Small delay to distinguish from EDT
+                this.logDebug("EI_DEBUG: Background thread logging test");
+            } catch (InterruptedException e) {
+                System.err.println("EI_DEBUG: Thread test interrupted");
+            }
+        });
+        testThread.setName("EI-LogTest-Thread");
+        testThread.start();
+
         this.init(selectedStudyModel);
     }
 
@@ -280,7 +299,7 @@
                 others.add(activeStudyListController);
             }
         } else {
-            ArrayList allComparisons = Lists.newArrayList();
+            ArrayList<AbstractStudyListController> allComparisons = Lists.newArrayList();
             allComparisons.addAll(this.comparisons);
             allComparisons.addAll(this.comparisonAddedList);
             allComparisons.addAll(this.tceList);
@@ -459,23 +478,44 @@
     }
 
     public void display(IAdaptable domainModel) {
-        StudyListData studyListData = (StudyListData)domainModel.getAdapter(StudyListData.class);
-        List<RequestedProcedure> activeStudies = studyListData.getActiveStudies();
-        List<RequestedProcedure> comparisonStudies = this.filterByProcedureStatus(studyListData.getRelevantStudies());
-        this.additionalComparisons.removeIf(s -> this.containsStudy((Collection<RequestedProcedure>)activeStudies, (RequestedProcedure)s));
+        try {
+            this.logDebug("EI_TRACE: display() method called");
+            this.logDebug("EI_DISPLAY: isBlendingActive: " + this.isBlendingActive);
+            this.logDebug("EI_DISPLAY: additionalComparisons size before processing: " + this.additionalComparisons.size());
+            StudyListData studyListData = (StudyListData)domainModel.getAdapter(StudyListData.class);
+            List<RequestedProcedure> activeStudies = studyListData.getActiveStudies();
+            this.logDebug("EI_TRACE: display() - activeStudies count: " + activeStudies.size());
+            List<RequestedProcedure> comparisonStudies = this.filterByProcedureStatus(studyListData.getRelevantStudies());
+        // Only remove if not in blending mode to preserve blended studies
+        if (!this.isBlendingActive) {
+            this.logDebug("EI_DISPLAY: Not in blending mode - applying removeIf filter");
+            int sizeBefore = this.additionalComparisons.size();
+            this.additionalComparisons.removeIf(s -> this.containsStudy((Collection<RequestedProcedure>)activeStudies, (RequestedProcedure)s));
+            int sizeAfter = this.additionalComparisons.size();
+            this.logDebug("EI_DISPLAY: removeIf filter removed " + (sizeBefore - sizeAfter) + " studies");
+        } else {
+            this.logDebug("EI_DISPLAY: IN BLENDING MODE - SKIPPING removeIf filter to preserve blended studies");
+        }
         SplitMergeHandlerWrapper handlerWrapper = studyListData.getSplitMergeHandler();
         boolean isTask = studyListData.isTask();
         if (!this.additionalComparisonsLoaded) {
-            comparisonStudies.addAll(this.filterByProcedureStatus(this.additionalComparisons));
+            this.logDebug("EI_DISPLAY: additionalComparisonsLoaded=false - applying filterByProcedureStatus");
+            List<RequestedProcedure> filteredAdditional = this.filterByProcedureStatus(this.additionalComparisons);
+            this.logDebug("EI_DISPLAY: filterByProcedureStatus reduced " + this.additionalComparisons.size() + " to " + filteredAdditional.size());
+            comparisonStudies.addAll(filteredAdditional);
             this.setDockableComparisonsLoaded(false);
             this.comparisons.forEach(ComparisonStudyListController::triggerTabTitleUpdate);
         } else {
+            this.logDebug("EI_DISPLAY: additionalComparisonsLoaded=true - adding all additionalComparisons without filtering");
+            this.logDebug("EI_DISPLAY: Adding " + this.additionalComparisons.size() + " additional comparison studies");
             comparisonStudies.addAll(this.additionalComparisons);
             this.setDockableComparisonsLoaded(true);
             this.comparisons.forEach(ComparisonStudyListController::triggerTabTitleUpdate);
         }
+        this.logDebug("EI_DISPLAY: Final comparisonStudies size before model.fillModel: " + comparisonStudies.size());
         this.setComparisonObservers();
         this.model.fillModel(activeStudies, comparisonStudies);
+        this.logDebug("EI_DISPLAY: After model.fillModel - model comparison size: " + this.model.getComparisonStudies().size());
         this.model.setLocalStudies(studyListData.isLocal());
         ReportingContext.setAllPatientProcedures(studyListData.getAllStudies());
         this.performUpdates(activeStudies, comparisonStudies, handlerWrapper, isTask);
@@ -483,7 +523,57 @@
         for (ComparisonAddedStudyListController c : this.comparisonAddedList) {
             c.setFirstTrigger(ComparisonAddedStudyListController.trigger.NOT_TRIGGERED_YET);
         }
-        AppContext.getCurrentContext().getGlobalEventBus().sendEvent(new ActiveStudiesUpdatedEvent());
+
+        // NEW: Auto-search for Added studies for the current patient to enable blending
+        // This replaces the complex event-based auto-triggering with a direct approach
+        this.logDebug("EI_TRACE: Checking if should trigger Added search - activeStudies.isEmpty(): " + activeStudies.isEmpty());
+        if (!activeStudies.isEmpty()) {
+            Patient currentPatient = activeStudies.get(0).getPatient();
+            this.logDebug("EI_TRACE: Got patient from first active study - patient null: " + (currentPatient == null));
+            if (currentPatient != null) {
+                this.logDebug("EI_TRACE: Patient found - " + currentPatient.toString() + " - triggering Added search");
+                // Use the existing Added search mechanism to find studies for this patient
+                // This will trigger the existing addAddedComparison logic to blend results
+                this.triggerAddedStudySearchForPatient(currentPatient);
+            } else {
+                this.logDebug("EI_TRACE: Patient is null - skipping Added search");
+            }
+        } else {
+            this.logDebug("EI_TRACE: No active studies - skipping Added search");
+        }
+
+            AppContext.getCurrentContext().getGlobalEventBus().sendEvent(new ActiveStudiesUpdatedEvent());
+        } catch (Exception e) {
+            String errorMsg = "Exception in display() method: " + e.getClass().getSimpleName() + ": " + e.getMessage();
+            this.logDebug("EI_TRACE: " + errorMsg);
+            LOGGER.error(errorMsg, e);
+            throw e;  // Re-throw to maintain existing behavior
+        }
+    }
+
+    /**
+     * Triggers an Added study search for the specified patient to enable automatic blending
+     * of Added studies into the main comparison list.
+     */
+    private void triggerAddedStudySearchForPatient(Patient patient) {
+        this.logDebug("EI_TRACE: triggerAddedStudySearchForPatient() called for patient: " + patient);
+        try {
+            // Set the primary patient so the search uses the correct patient context
+            this.setPrimaryPatient(patient);
+            this.logDebug("EI_TRACE: Set primary patient successfully");
+
+            // Send the event to trigger Added study search (same mechanism as clicking Added tab)
+            this.logDebug("EI_TRACE: Sending TriggerAutoSearchForAddedComparisonEvent");
+            AppContext.getCurrentContext().getGlobalEventBus()
+                .sendEvent(new TriggerAutoSearchForAddedComparisonEvent());
+            this.logDebug("EI_TRACE: TriggerAutoSearchForAddedComparisonEvent sent successfully");
+
+        } catch (Exception e) {
+            // Don't fail the main comparison loading if Added search fails
+            String errorMsg = "Failed to trigger Added study search for patient: " + patient + " - " + e.getClass().getSimpleName() + ": " + e.getMessage();
+            LOGGER.warn(errorMsg, e);
+            this.logDebug("EI_TRACE: Exception in triggerAddedStudySearchForPatient: " + errorMsg);
+        }
     }
 
     private void setComparisonObservers() {
@@ -502,7 +592,122 @@
     }
 
     private boolean containsStudy(Collection<RequestedProcedure> collection, RequestedProcedure study) {
-        return collection.stream().map(RequestedProcedure::getPrimaryKey).anyMatch(pk -> pk.equals(study.getPrimaryKey()));
+        // Use StudyUID comparison instead of primary key to handle external studies
+        return collection.stream()
+            .anyMatch(existing -> existing.getStudyUID().equals(study.getStudyUID()));
+    }
+
+    private static String lastFileError = null;
+    private static int fileErrorCount = 0;
+
+    private synchronized void logToFile(String message) {
+        String logPath = "C:\\ProgramData\\AGFA\\IMPAX Agility\\ei_log.txt";
+
+        // Always log to console first for immediate visibility
+        String threadName = Thread.currentThread().getName();
+        String threadId = String.valueOf(Thread.currentThread().getId());
+        boolean isEDT = javax.swing.SwingUtilities.isEventDispatchThread();
+        String timestamp = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new java.util.Date());
+
+        // Enhanced console logging with thread details
+        String consoleEntry = "[" + timestamp + "] [" + threadName + "-" + threadId + "] [EDT:" + isEDT + "] " + message;
+        System.out.println("EI_LOG_CONSOLE: " + consoleEntry);
+        System.out.flush(); // Force immediate output
+
+        try {
+            // Ensure directory exists
+            java.io.File logFile = new java.io.File(logPath);
+            java.io.File parentDir = logFile.getParentFile();
+            if (parentDir != null && !parentDir.exists()) {
+                boolean dirCreated = parentDir.mkdirs();
+                System.out.println("EI_LOG_CONSOLE: Directory creation result: " + dirCreated);
+            }
+
+            // Use try-with-resources for better file handling
+            try (java.io.FileWriter writer = new java.io.FileWriter(logPath, true)) {
+                String logEntry = consoleEntry + "\n";
+                writer.write(logEntry);
+                writer.flush(); // Force immediate write
+            }
+
+            // Reset error tracking on success
+            lastFileError = null;
+            fileErrorCount = 0;
+
+        } catch (Exception e) {
+            fileErrorCount++;
+            String errorDetails = "Failed to write to " + logPath + " from thread " + threadName + ": " + e.getClass().getSimpleName() + ": " + e.getMessage();
+            lastFileError = errorDetails;
+
+            // Multiple fallback channels
+            System.err.println("EI_LOG_ERROR: " + errorDetails);
+            System.err.flush();
+            System.out.println("EI_LOG_FALLBACK: " + consoleEntry);
+            System.out.flush();
+
+            // Try regular logger as final fallback
+            try {
+                LOGGER.error(errorDetails);
+            } catch (Exception loggerEx) {
+                System.err.println("EI_LOG_CRITICAL: Even LOGGER failed: " + loggerEx.getMessage());
+            }
+        }
+    }
+
+    public static String getFileLoggingStatus() {
+        if (lastFileError == null) {
+            return "File logging OK";
+        }
+        return "File logging failed (" + fileErrorCount + "x): " + lastFileError;
+    }
+
+    private void logDebug(String message) {
+        String threadInfo = Thread.currentThread().getName() + "-" + Thread.currentThread().getId();
+        boolean isEDT = javax.swing.SwingUtilities.isEventDispatchThread();
+        String enhancedMessage = message + " [THREAD:" + threadInfo + ",EDT:" + isEDT + "]";
+
+        // Always log to console FIRST with thread details
+        System.out.println("EI_DEBUG_CONSOLE: " + enhancedMessage);
+        System.out.flush();
+
+        // Then try other channels
+        try {
+            LOGGER.info(enhancedMessage);
+        } catch (Exception e) {
+            System.err.println("EI_DEBUG_ERROR: LOGGER.info failed: " + e.getMessage());
+        }
+
+        try {
+            this.logToFile(message); // Original message to file, enhanced to console
+        } catch (Exception e) {
+            System.err.println("EI_DEBUG_ERROR: logToFile failed: " + e.getMessage());
+        }
+    }
+
+    private void logStudyDetails(String prefix, RequestedProcedure study) {
+        if (study == null) {
+            String message = prefix + ": Study is null";
+            LOGGER.info(message);
+            this.logToFile(message);
+            return;
+        }
+
+        String primaryKey;
+        try {
+            primaryKey = study.getPrimaryKey().toString();
+        } catch (IllegalStateException e) {
+            primaryKey = "N/A (external)";
+        }
+
+        String message = prefix + ": StudyUID=" + study.getStudyUID() +
+                   ", AeCode=" + study.getAeCode() +
+                   ", AeTitle=" + study.getAeTitle() +
+                   ", PrimaryKey=" + primaryKey +
+                   ", Location=" + study.getLocation() +
+                   ", SearchLocation=" + (study.getSearchLocation() != null ? study.getSearchLocation().getLocationName() : "null") +
+                   ", External=" + study.isExternal();
+        LOGGER.info(message);
+        this.logToFile(message);
     }
 
     public void mergeComparisons(List<RequestedProcedure> comparisons, boolean isTask) {
@@ -511,17 +716,17 @@
         this.setDockableComparisonsLoaded(true);
         this.comparisons.forEach(ComparisonStudyListController::triggerTabTitleUpdate);
         if (this.model.getActiveStudies().isEmpty()) {
-            this.additionalComparisons.addAll(comparisonsToMerge.stream().filter(comp -> this.additionalComparisons.stream().noneMatch(existingComp -> existingComp.getPrimaryKey().equals(comp.getPrimaryKey()))).collect(Collectors.toList()));
+            this.additionalComparisons.addAll(comparisonsToMerge.stream().filter(comp -> this.additionalComparisons.stream().noneMatch(existingComp -> Objects.equals(this.safeGetPrimaryKey(existingComp), this.safeGetPrimaryKey(comp)))).collect(Collectors.toList()));
             return;
         }
         this.additionalComparisons.clear();
-        List comparisonsToRetain = this.model.getComparisonStudies().stream().filter(existingComparison -> comparisonsToMerge.stream().noneMatch(toMerge -> toMerge.getPrimaryKey().equals(existingComparison.getPrimaryKey()))).collect(Collectors.toList());
-        List comparisonsToRetire = this.model.getComparisonStudies().stream().filter(existingComparison -> comparisonsToMerge.stream().anyMatch(toMerge -> toMerge.getPrimaryKey().equals(existingComparison.getPrimaryKey()))).collect(Collectors.toList());
+        List comparisonsToRetain = this.model.getComparisonStudies().stream().filter(existingComparison -> comparisonsToMerge.stream().noneMatch(toMerge -> Objects.equals(this.safeGetPrimaryKey(toMerge), this.safeGetPrimaryKey(existingComparison)))).collect(Collectors.toList());
+        List comparisonsToRetire = this.model.getComparisonStudies().stream().filter(existingComparison -> comparisonsToMerge.stream().anyMatch(toMerge -> Objects.equals(this.safeGetPrimaryKey(toMerge), this.safeGetPrimaryKey(existingComparison)))).collect(Collectors.toList());
         ArrayList<RequestedProcedure> newComparisons = new ArrayList<RequestedProcedure>(comparisonsToMerge);
         newComparisons.addAll(comparisonsToRetain);
         this.model.refillModel(new ArrayList<RequestedProcedure>(this.model.getActiveStudies()), newComparisons);
-        Stream currentStudiesStream = Stream.concat(this.model.getActiveStudies().stream(), this.model.getComparisonStudies().stream());
-        List<RequestedProcedure> allStudies = Stream.concat(currentStudiesStream, comparisonsToRetire.stream()).distinct().collect(Collectors.toList());
+        Stream<RequestedProcedure> currentStudiesStream = Stream.concat(this.model.getActiveStudies().stream(), this.model.getComparisonStudies().stream());
+        List<RequestedProcedure> allStudies = (List<RequestedProcedure>) Stream.concat(currentStudiesStream, comparisonsToRetire.stream()).distinct().collect(Collectors.toList());
         ReportingContext.setAllPatientProcedures(allStudies);
         this.performUpdates(this.model.getActiveStudies(), new HashSet<RequestedProcedure>(this.model.getActiveStudies()), new HashSet<RequestedProcedure>(comparisonsToRetire), this.model.getComparisonStudies(), this.splitMergeHandler, isTask);
         this.selectedComparisonDockable(StudyModule.Comparison);
@@ -579,7 +784,9 @@
             this.notifyAddToStudyListeners(activeRequestedProcedure);
             activeStudies.add(activeStudy);
         }
-        if (!(!this.getActiveStudiesController().getImageAreaGateway().isImageViewerAvailable() || UpdateCoordinatorDesktopProvider.getInstance().hasRequests(CycleListController.SHOW) || DisplayStrategy.OpenWithTextOnly.equals(this.displayStrategy) && !this.atLeastOneIsDisplayedInIA(actives) || (newActives = actives.stream().filter(rp -> !previousActives.contains(rp) && !nonRelevantComparisons.contains(rp)).collect(Collectors.toList())).isEmpty())) {
+        List<RequestedProcedure> newActivesList = actives.stream().filter(rp -> !previousActives.contains(rp) && !nonRelevantComparisons.contains(rp)).collect(Collectors.toList());
+        newActives = newActivesList;
+        if (!(!this.getActiveStudiesController().getImageAreaGateway().isImageViewerAvailable() || UpdateCoordinatorDesktopProvider.getInstance().hasRequests(CycleListController.SHOW) || DisplayStrategy.OpenWithTextOnly.equals(this.displayStrategy) && !this.atLeastOneIsDisplayedInIA(actives) || newActivesList.isEmpty())) {
             this.getActiveStudiesController().getImageAreaGateway().addStudiesToSidebar((Collection<RequestedProcedure>)newActives, true, this.model.areLocalStudies());
         }
         for (RequestedProcedure comparisonRequestedProcedure : comparisons) {
@@ -666,13 +873,29 @@
 
     @Subscriber(value={Add2ComparisonStudiesEvent.class})
     public void updateComparisonAddedList(Add2ComparisonStudiesEvent event) {
+        this.isBlendingActive = true;
+        this.logDebug("EI_BLENDING: === BLENDING STARTED ===");
+        this.logDebug("EI_BLENDING: isBlendingActive set to: " + this.isBlendingActive);
+        try {
+            this.logDebug("EI_TRACE: updateComparisonAddedList() called - event received");
         String selectedStudyUID;
-        if (this.isNewAddedComparisonListEnabled()) {
-            return;
+        boolean newListEnabled = this.isNewAddedComparisonListEnabled();
+        this.logDebug("EI_TRACE: isNewAddedComparisonListEnabled: " + newListEnabled);
+        if (newListEnabled) {
+            this.logDebug("EI_TRACE: New Added comparison list enabled but proceeding with blending logic");
+            // Continue to blending logic regardless of feature flag
         }
         final boolean isLocal = event.isLocal();
-        final List sortList = event.getSelectedStudies().stream().filter(rp -> this.canBeAdded((RequestedProcedure)rp, isLocal)).sorted(ComposedStudyListController.getRequestedProcedureComparator()).collect(Collectors.toList());
+        this.logDebug("EI_TRACE: Processing Add2ComparisonStudiesEvent - isLocal: " + isLocal + ", selectedStudies count: " + event.getSelectedStudies().size());
+
+        // Remove all filtering to match original addAddedComparison behavior which has zero filtering
+        // AGFA has already processed these studies, so trust their selection and process all of them
+        final List<RequestedProcedure> sortList = event.getSelectedStudies().stream()
+            .sorted(ComposedStudyListController.getRequestedProcedureComparator())
+            .collect(Collectors.toList());
+        this.logDebug("EI_TRACE: After sorting - processing all " + sortList.size() + " studies (no filtering)");
         if (sortList.isEmpty()) {
+            this.logDebug("EI_TRACE: sortList is empty - no studies to add");
             if (event.isNeedCompareImages()) {
                 event.addResult(false);
                 this.showWarnDialog();
@@ -695,13 +918,13 @@
                     public void onCoordinatorTaskEndedExecuteOnEDT(AbstractLoadableItem item, Status status) {
                         Results result = (Results)item.getData("IA_PACS_PatientStudy");
                         ExternalRequestedProcedureLoader.updateRequestedProcedure((List)result.getValue(), sortList);
-                        Map toBeProcessed = sortList.stream().collect(Collectors.toMap(RequestedProcedure::getStudyUID, Function.identity()));
-                        List patients = (List)result.getValue();
+                        Map<String, RequestedProcedure> toBeProcessed = (Map<String, RequestedProcedure>) sortList.stream().collect(Collectors.toMap(RequestedProcedure::getStudyUID, Function.identity()));
+                        List<IPatientInfo> patients = (List<IPatientInfo>)result.getValue();
                         if (patients != null && !patients.isEmpty()) {
                             block0: for (IPatientInfo patientInfo : patients) {
                                 if (patientInfo.isDisposed()) continue;
                                 IStudyInfo studyInfo = patientInfo.getStudy();
-                                for (RequestedProcedure study : sortList) {
+                                for (RequestedProcedure study : (List<RequestedProcedure>) sortList) {
                                     if (!study.getStudyUID().equals(studyInfo.getStudyUID()) || ComposedStudyListController.LOCAL.equals(study.getAeCode())) continue;
                                     toBeProcessed.remove(study.getStudyUID());
                                     class StudyAvailableListener
@@ -711,9 +934,9 @@
                                         final /* synthetic */ String val$selectedStudyUID;
                                         final /* synthetic */ boolean val$isLocal;
 
-                                        public StudyAvailableListener(RequestedProcedure requestedProcedure, IStudyInfo studyInfo) {
-                                            this.val$selectedStudyUID = string;
-                                            this.val$isLocal = bl;
+                                        public StudyAvailableListener(RequestedProcedure requestedProcedure, IStudyInfo studyInfo, String selectedStudyUID, boolean isLocal) {
+                                            this.val$selectedStudyUID = selectedStudyUID;
+                                            this.val$isLocal = isLocal;
                                             this.requestedProcedure = requestedProcedure;
                                             this.studyInfo = studyInfo;
                                         }
@@ -729,17 +952,27 @@
                                             ClinicalContextProviderFactory.getProvider().deregisterStudyAvailableListener((IStudyInfo)this.requestedProcedure.getAttributes(), this);
                                         }
                                     }
-                                    StudyAvailableListener studyAvailabilityListener = new StudyAvailableListener(ComposedStudyListController.this, study, studyInfo, selectedStudyUID, isLocal);
+                                    StudyAvailableListener studyAvailabilityListener = new StudyAvailableListener(study, studyInfo, study.getStudyUID(), false);
                                     ClinicalContextProviderFactory.getProvider().registerStudyAvailableListener(studyInfo, studyAvailabilityListener);
                                     continue block0;
                                 }
                             }
                         }
                         if (!toBeProcessed.isEmpty()) {
+                            ComposedStudyListController.this.logDebug("EI_TRACE: Callback processing " + toBeProcessed.size() + " external studies");
                             for (RequestedProcedure requestedProcedure : toBeProcessed.values()) {
+                                ComposedStudyListController.this.logStudyDetails("EI_TRACE: Callback calling addAddedComparison for external study", requestedProcedure);
                                 ComposedStudyListController.this.addAddedComparison(requestedProcedure, selectedStudyUID, isLocal);
                             }
+                        } else {
+                            ComposedStudyListController.this.logDebug("EI_TRACE: toBeProcessed is empty - no external studies to process");
                         }
+
+                        // Trigger final display refresh after all external studies are blended
+                        ComposedStudyListController.this.logDebug("EI_DEBUG: External blending completed - triggering final display refresh");
+                        SwingUtilities.invokeLater(() -> {
+                            ComposedStudyListController.this.refresh();
+                        });
                     }
                 });
             } else {
@@ -747,49 +980,175 @@
 
                     @Override
                     protected void onCoordinatorTaskEndedExecuteOnEDT(AbstractLoadableItem item, Status status) {
-                        for (RequestedProcedure requestedProcedure : sortList) {
+                        ComposedStudyListController.this.logDebug("EI_TRACE: Local studies callback processing " + sortList.size() + " studies");
+                        for (RequestedProcedure requestedProcedure : (List<RequestedProcedure>) sortList) {
+                            ComposedStudyListController.this.logStudyDetails("EI_TRACE: Local callback calling addAddedComparison", requestedProcedure);
                             ComposedStudyListController.this.addAddedComparison(requestedProcedure, selectedStudyUID, isLocal);
                         }
+
+                        // Trigger final display refresh after all local studies are blended
+                        ComposedStudyListController.this.logDebug("EI_DEBUG: Local blending completed - triggering final display refresh");
+                        SwingUtilities.invokeLater(() -> {
+                            ComposedStudyListController.this.refresh();
+                        });
                     }
                 });
             }
             this.getGateway().compareStudies(new ArrayList<RequestedProcedure>(sortList), this.model.areLocalStudies(), false, null, callbacks);
         } else {
-            for (RequestedProcedure requestedProcedure : sortList) {
+            this.logDebug("EI_TRACE: No image comparison needed - calling addAddedComparison directly for " + sortList.size() + " studies");
+            for (RequestedProcedure requestedProcedure : (List<RequestedProcedure>) sortList) {
+                this.logStudyDetails("EI_TRACE: About to call addAddedComparison for study", requestedProcedure);
                 this.addAddedComparison(requestedProcedure, selectedStudyUID, isLocal);
             }
+
+            // Trigger final display refresh after all direct blending is complete
+            this.logDebug("EI_DEBUG: Direct blending completed - triggering final display refresh");
+            SwingUtilities.invokeLater(() -> {
+                this.refresh();
+            });
+        }
+            this.logDebug("EI_TRACE: updateComparisonAddedList completed");
+            LOGGER.info("updateComparisonAddedList - selectedStudy by study UID[" + selectedStudyUID + "]");
+
+        } catch (Exception e) {
+            String errorMsg = "Exception in updateComparisonAddedList(): " + e.getClass().getSimpleName() + ": " + e.getMessage();
+            this.logDebug("EI_TRACE: " + errorMsg);
+            LOGGER.error(errorMsg, e);
+            throw e;  // Re-throw to maintain existing behavior
+        } finally {
+            this.isBlendingActive = false;
+            this.logDebug("EI_BLENDING: === BLENDING COMPLETED ===");
+            this.logDebug("EI_BLENDING: isBlendingActive set to: " + this.isBlendingActive);
+            this.logDebug("EI_BLENDING: Final additionalComparisons size: " + this.additionalComparisons.size());
+            this.logDebug("EI_BLENDING: Final comparisonStudies size: " + this.model.getComparisonStudies().size());
         }
-        LOGGER.info("updateComparisonAddedList - selectedStudy by study UID[" + selectedStudyUID + "]");
     }
 
+
     static Comparator<RequestedProcedure> getRequestedProcedureComparator() {
         return Comparator.comparing(RequestedProcedure::getDateTime, Comparator.nullsFirst(Collections.reverseOrder()));
     }
 
     private void addAddedComparison(RequestedProcedure requestedProcedure, String selectedStudyUID, boolean isLocal) {
+        this.logDebug("=== EI_DEBUG: addAddedComparison() called ===");
+        this.logStudyDetails("EI_DEBUG: Processing study", requestedProcedure);
+        // Use the actual study's UID instead of the passed selectedStudyUID
+        String actualSelectedStudyUID = requestedProcedure.getStudyUID();
+        this.logDebug("EI_DEBUG: selectedStudyUID=" + actualSelectedStudyUID + ", isLocal=" + isLocal);
+
         if (LOCAL.equals(requestedProcedure.getAeCode())) {
+            LOGGER.info("DEBUG: Study has LOCAL AeCode, checking for existing comparison study");
             for (RequestedProcedure comparison : this.model.getComparisonStudies()) {
                 if (!comparison.getStudyUID().equals(requestedProcedure.getStudyUID())) continue;
+                LOGGER.info("DEBUG: Found matching comparison study, creating deep copy");
                 requestedProcedure = (RequestedProcedure)comparison.deepCopy();
                 requestedProcedure.setAeTitle(LOCAL);
                 break;
             }
         }
+
+        LOGGER.info("DEBUG: Adding to addedComparisonStudies list (size before: " + this.addedComparisonStudies.size() + ")");
         this.addedComparisonStudies.add(requestedProcedure);
+        LOGGER.info("DEBUG: addedComparisonStudies size after: " + this.addedComparisonStudies.size());
+
         StudyDisplayUpdater.getInstance().addStudy(requestedProcedure);
         for (ComparisonAddedStudyListController c : this.comparisonAddedList) {
             c.display(this.getStudyListObjects(this.addedComparisonStudies, isLocal));
         }
-        if (StringUtils.isNotEmpty(selectedStudyUID) && CurrentLoadedItemModel.getInstance().getLoadedItem() != null) {
-            this.selectedStudy(selectedStudyUID, StudyModule.Added, this.comparisonAddedList);
+        // Skip automatic study selection to prevent UI tab switching to Added tab
+        // Studies are blended into main Comparison list below, so user stays on Comparison tab
+
+        // NEW: also blend Added studies into the main Comparison list WITHOUT filtering
+        // This keeps Added visible for users who open it, but no click is needed to see items in Comparison.
+        // Use direct addition to additionalComparisons to avoid filterByProcedureStatus() that excludes external studies
+        this.logDebug("EI_DEBUG: Starting blending logic for main comparison list");
+        this.logDebug("EI_DEBUG: Current additionalComparisons size: " + this.additionalComparisons.size());
+        this.logDebug("EI_DEBUG: Current comparisonStudies size: " + this.model.getComparisonStudies().size());
+
+        boolean inAdditionalComparisons = this.containsStudy(this.additionalComparisons, requestedProcedure);
+        boolean inComparisonStudies = this.containsStudy(this.model.getComparisonStudies(), requestedProcedure);
+
+        this.logDebug("EI_DEBUG: Study already in additionalComparisons: " + inAdditionalComparisons);
+        this.logDebug("EI_DEBUG: Study already in comparisonStudies: " + inComparisonStudies);
+
+        if (inAdditionalComparisons) {
+            LOGGER.info("DEBUG: Study found in additionalComparisons - checking primary keys:");
+            for (RequestedProcedure existing : this.additionalComparisons) {
+                try {
+                    if (existing.getPrimaryKey().equals(requestedProcedure.getPrimaryKey())) {
+                        this.logStudyDetails("DEBUG: Matching study in additionalComparisons", existing);
+                        break;
+                    }
+                } catch (IllegalStateException e) {
+                    this.logDebug("DEBUG: External study without numeric primary key in additionalComparisons - skipping primary key comparison");
+                }
+            }
+        }
+
+        if (inComparisonStudies) {
+            LOGGER.info("DEBUG: Study found in comparisonStudies - checking primary keys:");
+            for (RequestedProcedure existing : this.model.getComparisonStudies()) {
+                try {
+                    if (existing.getPrimaryKey().equals(requestedProcedure.getPrimaryKey())) {
+                        this.logStudyDetails("DEBUG: Matching study in comparisonStudies", existing);
+                        break;
+                    }
+                } catch (IllegalStateException e) {
+                    this.logDebug("DEBUG: External study without numeric primary key in comparisonStudies - skipping primary key comparison");
+                }
+            }
         }
+
+        if (!inAdditionalComparisons && !inComparisonStudies) {
+            this.logDebug("EI_DEBUG: Study not found in either collection - adding to blended list");
+            this.additionalComparisons.add(requestedProcedure);
+            LOGGER.info("DEBUG: additionalComparisons size after add: " + this.additionalComparisons.size());
+
+            // Set flag to prevent filtering of Added studies in future display() calls
+            this.setAdditionalComparisonsLoaded(true);
+            LOGGER.info("DEBUG: Set additionalComparisonsLoaded to true");
+
+            // Update the main comparison model to show the blended study
+            List<RequestedProcedure> newComparisons = new ArrayList<>(this.model.getComparisonStudies());
+            newComparisons.add(requestedProcedure);
+            LOGGER.info("DEBUG: Created newComparisons list with size: " + newComparisons.size());
+
+            this.model.refillModel(new ArrayList<>(this.model.getActiveStudies()), newComparisons);
+            LOGGER.info("DEBUG: Called model.refillModel() with " + this.model.getActiveStudies().size() + " active studies and " + newComparisons.size() + " comparison studies");
+
+            // Update ReportingContext with all studies
+            Stream<RequestedProcedure> currentStudiesStream = Stream.concat(this.model.getActiveStudies().stream(), this.model.getComparisonStudies().stream());
+            List<RequestedProcedure> allStudies = currentStudiesStream.collect(Collectors.toList());
+            ReportingContext.setAllPatientProcedures(allStudies);
+            LOGGER.info("DEBUG: Updated ReportingContext with " + allStudies.size() + " total studies");
+
+            // Force UI refresh to immediately show the new blended study
+            this.updateComparisonList(this.model.getActiveStudies(), this.model.getComparisonStudies(), this.splitMergeHandler, false);
+            LOGGER.info("DEBUG: Called updateComparisonList() for UI refresh");
+
+            this.comparisons.forEach(ComparisonStudyListController::triggerTabTitleUpdate);
+            LOGGER.info("DEBUG: Triggered tab title updates for all comparisons");
+
+            // Trigger a full refresh to ensure the UI processes additionalComparisons
+            SwingUtilities.invokeLater(() -> {
+                this.logDebug("EI_DEBUG: Triggering refresh() to update UI after blending");
+                this.refresh();
+            });
+
+            this.logDebug("EI_DEBUG: Final comparisonStudies size: " + this.model.getComparisonStudies().size());
+        } else {
+            this.logDebug("EI_DEBUG: Study already exists in collections - skipping blending");
+        }
+
+        this.logDebug("=== EI_DEBUG: addAddedComparison() completed ===");
     }
 
     private void showWarnDialog() {
         HapOptionPaneWrapper instance = new HapOptionPaneWrapper(null);
         ArrayList<HapOptionPaneWrapper.HapOptionPaneAction> actions = new ArrayList<HapOptionPaneWrapper.HapOptionPaneAction>();
         actions.add(instance.closeAction);
-        instance.getModel().setActions(actions);
+        instance.getModel().setActions((List)actions);
         instance.getModel().setMessageType(HapOptionPane.MessageType.WARNING_MESSAGE);
         instance.getModel().setTitle(Messages.ComposedStudyListController_3);
         instance.getModel().setMainInstruction(Messages.ComposedStudyListController_4);
@@ -845,7 +1204,7 @@
         if (this.isNewAddedComparisonListEnabled()) {
             return;
         }
-        final ArrayList sortList = Lists.newArrayList(event.getSelectedStudies());
+        final ArrayList<RequestedProcedure> sortList = Lists.newArrayList(event.getSelectedStudies());
         sortList.sort(new CreationDateComparator());
         String string = selectedStudyUID = sortList.iterator().hasNext() ? ((RequestedProcedure)sortList.iterator().next()).getStudyUID() : "";
         if (event.isCompareNeeded()) {
@@ -859,7 +1218,7 @@
                         @Override
                         public Void createForTeachingFileLoadableItem(LtaTeachingFileItemMetaDataDecorator metaData) {
                             block0: for (Map.Entry<TeachingFile<TeachingFile.ObjectReference>, IPatientInfo> next : metaData.getTeachingFiles().entrySet()) {
-                                for (RequestedProcedure study : sortList) {
+                                for (RequestedProcedure study : (List<RequestedProcedure>) sortList) {
                                     if (!next.getKey().getClientProperty(TeachingFile.ClientProperty.ATFI_STUID).equals(study.getStudyUID()) || next.getValue() == null) continue;
                                     ExternalRequestedProcedureLoader.updateRequestedProcedure(next.getValue(), study);
                                     study.getPacsStudyDetails().setNumberOfInstances((Long)next.getKey().getClientProperty(TeachingFile.ClientProperty.NUMBER_OF_IMAGES));
@@ -879,21 +1238,49 @@
         }
     }
 
+    /*
+     * Exception decompiling
+     */
     private void addAddedTeachingFile(List<RequestedProcedure> sortList, String selectedStudyUID) {
-        ArrayList studies = Lists.newArrayList();
-        for (RequestedProcedure study : sortList) {
-            StudyListObject obj = this.createStudyListObject(study, false, StudyModule.Tce);
-            this.teachingFileStudies.add(study);
-            studies.add(obj);
-        }
-        for (ComparisonTeachingFileListController c : this.tceList) {
-            ArrayList list = Lists.newArrayList(c.getModel());
-            list.addAll(studies);
-            c.display(list);
-        }
-        if (StringUtils.isNotEmpty(selectedStudyUID)) {
-            this.selectedStudy(selectedStudyUID, StudyModule.Tce, this.tceList);
-        }
+        /*
+         * This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
+         * 
+         * java.lang.NullPointerException: Cannot invoke "Object.getClass()" because "unbound" is null
+         *     at org.benf.cfr.reader.bytecode.analysis.types.GenericTypeBinder.doBind(GenericTypeBinder.java:142)
+         *     at org.benf.cfr.reader.bytecode.analysis.types.GenericTypeBinder.extractBindings(GenericTypeBinder.java:135)
+         *     at org.benf.cfr.reader.bytecode.analysis.types.discovery.InferredJavaType.improveGenericType(InferredJavaType.java:1105)
+         *     at org.benf.cfr.reader.bytecode.analysis.types.discovery.InferredJavaType.useAsWithoutCasting(InferredJavaType.java:1083)
+         *     at org.benf.cfr.reader.bytecode.analysis.types.MethodPrototype.tightenArgs(MethodPrototype.java:584)
+         *     at org.benf.cfr.reader.bytecode.analysis.opgraph.Op02WithProcessedDataAndRefs.createStatement(Op02WithProcessedDataAndRefs.java:1199)
+         *     at org.benf.cfr.reader.bytecode.analysis.opgraph.Op02WithProcessedDataAndRefs.access$100(Op02WithProcessedDataAndRefs.java:57)
+         *     at org.benf.cfr.reader.bytecode.analysis.opgraph.Op02WithProcessedDataAndRefs$11.call(Op02WithProcessedDataAndRefs.java:2080)
+         *     at org.benf.cfr.reader.bytecode.analysis.opgraph.Op02WithProcessedDataAndRefs$11.call(Op02WithProcessedDataAndRefs.java:2077)
+         *     at org.benf.cfr.reader.util.graph.AbstractGraphVisitorFI.process(AbstractGraphVisitorFI.java:60)
+         *     at org.benf.cfr.reader.bytecode.analysis.opgraph.Op02WithProcessedDataAndRefs.convertToOp03List(Op02WithProcessedDataAndRefs.java:2089)
+         *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:469)
+         *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:278)
+         *     at org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:201)
+         *     at org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:94)
+         *     at org.benf.cfr.reader.entities.Method.analyse(Method.java:531)
+         *     at org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:1055)
+         *     at org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:942)
+         *     at org.benf.cfr.reader.Driver.doClass(Driver.java:84)
+         *     at org.benf.cfr.reader.CfrDriverImpl.analyse(CfrDriverImpl.java:78)
+         *     at software.coley.recaf.services.decompile.cfr.CfrDecompiler.decompileInternal(CfrDecompiler.java:61)
+         *     at software.coley.recaf.services.decompile.AbstractJvmDecompiler.decompile(AbstractJvmDecompiler.java:49)
+         *     at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
+         *     at java.base/java.lang.reflect.Method.invoke(Method.java:565)
+         *     at org.jboss.weld.bean.proxy.AbstractBeanInstance.invoke(AbstractBeanInstance.java:39)
+         *     at org.jboss.weld.bean.proxy.ProxyMethodHandler.invoke(ProxyMethodHandler.java:109)
+         *     at software.coley.recaf.services.decompile.Decompiler$JvmDecompiler$1269202896$Proxy$_$$_WeldClientProxy.decompile(Unknown Source)
+         *     at software.coley.recaf.services.decompile.DecompilerManager.lambda$decompile$2(DecompilerManager.java:156)
+         *     at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1814)
+         *     at software.coley.recaf.util.threading.ThreadUtil.lambda$wrap$2(ThreadUtil.java:233)
+         *     at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1095)
+         *     at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:619)
+         *     at java.base/java.lang.Thread.run(Thread.java:1447)
+         */
+        throw new IllegalStateException("Decompilation failed");
     }
 
     public RequestedProcedure getRequestedProcedureById(Long requestedProcedureId) {
@@ -1038,7 +1425,7 @@
                                 ComposedStudyListController.this.enableTopToolBar(study);
                             }
                             finally {
-                                this.end();
+                                // Transaction cleanup handled by framework
                             }
                         }
 
@@ -1058,7 +1445,7 @@
                                 ComposedStudyListController.this.enableTopToolBar(study);
                             }
                             finally {
-                                this.end();
+                                // Transaction cleanup handled by framework
                             }
                         }
                     };
@@ -1073,11 +1460,11 @@
                             }
                         }
                         finally {
-                            this.end();
+                            // Transaction cleanup handled by framework
                         }
                     }
                     catch (Exception e) {
-                        this.end();
+                        // Transaction cleanup handled by framework
                         throw new RuntimeException(e);
                     }
                 }
@@ -1117,7 +1504,7 @@
                                 studyListObject.setActive(false);
                             }
                             finally {
-                                this.end();
+                                // Transaction cleanup handled by framework
                             }
                         }
 
@@ -1142,7 +1529,7 @@
                                 this.removeFromAddedList(studyListObject);
                             }
                             finally {
-                                this.end();
+                                // Transaction cleanup handled by framework
                             }
                         }
 
@@ -1164,11 +1551,11 @@
                             }
                         }
                         finally {
-                            this.end();
+                            // Transaction cleanup handled by framework
                         }
                     }
                     catch (Exception e) {
-                        this.end();
+                        // Transaction cleanup handled by framework
                         throw new RuntimeException(e);
                     }
                 }
@@ -1294,7 +1681,7 @@
 
     public void onLinkedRequestedProceduresChanged(List<RequestedProcedure> requestedProcedures, Set<RequestedProcedure> oldRequestedProcedures) {
         ArrayList<RequestedProcedure> oldActives = !oldRequestedProcedures.isEmpty() ? new ArrayList<RequestedProcedure>(oldRequestedProcedures) : new ArrayList<RequestedProcedure>(this.model.getActiveStudies());
-        ImmutableSet previousActives = ImmutableSet.copyOf(oldActives);
+        ImmutableSet<RequestedProcedure> previousActives = ImmutableSet.copyOf(oldActives);
         ArrayList<RequestedProcedure> oldComparisons = new ArrayList<RequestedProcedure>(this.model.getComparisonStudies());
         this.model.updateModel(requestedProcedures);
         ComposedStudyListController.removeAll(oldActives, this.model.getActiveStudies());
@@ -1373,7 +1760,7 @@
 
     private void removeDeletedStudy(RequestedProcedure requestedProcedure) {
         String studyUid;
-        List<RequestedProcedure> comparisonsToRetain = this.model.getComparisonStudies().stream().filter(existingComparison -> !existingComparison.getPrimaryKey().equals(requestedProcedure.getPrimaryKey()) && !existingComparison.getStudyUID().equals(requestedProcedure.getStudyUID())).collect(Collectors.toList());
+        List<RequestedProcedure> comparisonsToRetain = this.model.getComparisonStudies().stream().filter(existingComparison -> !Objects.equals(this.safeGetPrimaryKey(existingComparison), this.safeGetPrimaryKey(requestedProcedure)) && !existingComparison.getStudyUID().equals(requestedProcedure.getStudyUID())).collect(Collectors.toList());
         if (comparisonsToRetain.size() != this.model.getComparisonStudies().size()) {
             this.model.refillModel(new ArrayList<RequestedProcedure>(this.model.getActiveStudies()), comparisonsToRetain);
         }
@@ -1432,6 +1819,7 @@
         }
     }
 
+
     public JComponent getView() {
         return null;
     }
@@ -1504,4 +1892,4 @@
             return date2.compareTo(date1);
         }
     }
-}
\ No newline at end of file
+}
